<?php
// $Id$
/**
 * @file
 * Subversion backend for Version Control API - Provides Subversion commit
 * information and account management as a pluggable backend.
 *
 * Copyright 2007, 2008 by Jakob Petsovits ("jpetso", http://drupal.org/user/56020)
 */

// Server types.
// For the repository settings' "Allowed server types" for accounts, this is
// a flag where allowed values are combined with the bitwise or ("|")operator,
// and can be deassembled with the bitwise and ("&").
define('VERSIONCONTROL_SVN_SERVER_APACHE_WEBDAV', 1); // Apache with mod_dav_svn (http(s)://)
define('VERSIONCONTROL_SVN_SERVER_SVNSERVE',      2); // Plain svnserve (svn://)
define('VERSIONCONTROL_SVN_SERVER_SVNSERVE_SSH',  4); // svnserve over SSH (svn+ssh://)

// Update methods.
define('VERSIONCONTROL_SVN_UPDATE_CRON',          1);
define('VERSIONCONTROL_SVN_UPDATE_XSVN',          2);

// The admin and user edit pages.
include_once(drupal_get_path('module', 'versioncontrol_svn') .'/versioncontrol_svn.forms.inc');

/**
 * Implementation of hook_versioncontrol_backends().
 *
 * @return
 *   A structured array containing information about this known backends.
 *   Array key is the unique string identifier of the version control system.
 *   The corresponding array values are again structured arrays and consist
 *   of elements with the following keys:
 *
 *   'name': The user-visible name of the VCS.
 *   'description': A short description of the backend, if possible not longer
 *                  than one or two sentences.
 *   'capabilities': An array listing optional capabilities, in addition to the
 *                   required functionality like retrieval of detailed
 *                   commit information. Array values can be an arbitrary
 *                   combination of VERSIONCONTROL_CAPABILITY_* values. If no
 *                   additional capabilities are supported by the backend,
 *                   this array will be empty.
 *   'autoadd': An array listing which tables should be managed by
 *              Version Control API instead of doing it manually in
 *              the backend. Array values can be an arbitrary combination of
 *              VERSIONCONTROL_AUTOADD_* values. If no array additions
 *              should be automatically managed, this array will be empty.
 */
function versioncontrol_svn_versioncontrol_backends() {
  return array(
    // The array key is up to 8 characters long, and used as unique identifier
    // for this VCS, in functions, URLs and in the database.
    'svn' => array(
      // The user-visible name of the VCS.
      'name' => 'Subversion',

      // A short description of the VCS, if possible not longer than one or two sentences.
      'description' => t('Subversion (SVN) is a code management system that supports file and directory revisions, atomic commits, serverless diffs and renaming items. Tags and branches are emulated by directory naming conventions, and merge functionality is still lacking.'),

      // A list of optional capabilities, in addition to the required retrieval
      // of detailed commit information.
      'capabilities' => array(
        // Able to cancel commits if the committer lacks permissions
        // to commit to specific paths and/or branches.
        // Not implemented yet.
        //VERSIONCONTROL_CAPABILITY_COMMIT_RESTRICTIONS,
        // Able to cancel branch or tag assignments if the committer lacks
        // permissions to create/update/delete those.
        // Not implemented yet.
        //VERSIONCONTROL_CAPABILITY_BRANCH_TAG_RESTRICTIONS,
        // Able to retrieve a file or its revision number based on a global
        // revision identifier.
        VERSIONCONTROL_CAPABILITY_ATOMIC_COMMITS,
      ),

      // An array listing which tables should be managed by Version Control API
      // instead of doing it manually in the backend.
      'flags' => array(
        // versioncontrol_insert_repository() will automatically insert
        // array elements from $repository['svn_specific'] into
        // {versioncontrol_svn_repositories} and versioncontrol_get_repositories()
        // will automatically fetch it from there.
        VERSIONCONTROL_FLAG_AUTOADD_REPOSITORIES,
      ),
    ),
  );
}

/**
 * Implementation of hook_menu().
 */
function versioncontrol_svn_menu($may_cache) {
  global $user;
  $items = array();
  $admin_access = user_access('administer version control systems');

  if ($may_cache) {
    $items[] = array(
      'path' => 'admin/project/versioncontrol-repositories/update/svn',
      'title' => t('Fetch log'),
      'callback' => 'versioncontrol_svn_update_repository_callback',
      'access' => $admin_access,
      'type' => MENU_CALLBACK,
    );
  }
  return $items;
}

/**
 * Implementation of hook_cron():
 * Update repositories that have log fetching enabled.
 */
function versioncontrol_svn_cron() {
  $result = db_query("SELECT repo_id FROM {versioncontrol_svn_repositories}
                      WHERE update_method = %d", VERSIONCONTROL_SVN_UPDATE_CRON);

  // Set timeout limit to 3600 seconds as it can take a long time to process
  // the log initially. (And hook_cron() might be called by poormanscron.)
  if (!ini_get('safe_mode')) {
    set_time_limit(3600);
  }
  while ($repo = db_fetch_object($result)) {
    $repository = versioncontrol_get_repository($repo->repo_id);
    if (isset($repository)) {
      _versioncontrol_svn_update_repository($repository);
    }
  }
}


/**
 * Get the list of allowed server types for the given repository
 * that new accounts can choose from. Essentially, this function decodes
 * the integer number that is stored in the database to a comfortable array.
 *
 * @param $repository
 *   The repository array, as returned by versioncontrol_get_repository().
 *   May also be NULL, in which case an empty array will be returned.
 *
 * @return
 *   An array containing any combination (but at least one) of the
 *   server type constants VERSIONCONTROL_SVN_SERVER_APACHE_WEBDAV,
 *   VERSIONCONTROL_SVN_SERVER_SVNSERVE and VERSIONCONTROL_SVN_SERVER_SVNSERVE_SSH.
 */
function versioncontrol_svn_get_allowed_serving_methods($repository = NULL) {
  if (!isset($repository['svn_specific']['allowed_serving_methods'])) {
    return array();
  }

  $server_types = array(
    VERSIONCONTROL_SVN_SERVER_APACHE_WEBDAV,
    VERSIONCONTROL_SVN_SERVER_SVNSERVE,
    VERSIONCONTROL_SVN_SERVER_SVNSERVE_SSH,
  );
  $allowed_types_binary = $repository['svn_specific']['allowed_serving_methods'];
  $allowed_types_array = array();

  foreach ($server_types as $mask) {
    if (($allowed_types_binary & $mask) != 0) {
      $allowed_types_array[] = $mask;
    }
  }
  return $allowed_types_array;
}


/**
 * Implementation of [versioncontrol_backend]_get_selected_operation_item_label():
 * Retrieve the tag or branch that applied to that item during the given
 * operation. The result of this function will be used for the 'selected_label'
 * property of each item, which is necessary to provide a starting point for
 * branch and tag navigation.
 */
function versioncontrol_svn_get_selected_operation_item_label($operation, $item) {
  // No branch/tag support yet, might be implemented in the future.
  return NULL;
}

/**
 * Implementation of [versioncontrol_backend]_get_selected_source_item_label():
 * Retrieve the tag or branch that applied to the source item of a given
 * successor item revision (a.k.a. "target item"). The result of this function
 * will be used for the 'selected_label' property of each item, which is
 * necessary to provide a starting point for branch and tag navigation.
 */
function versioncontrol_svn_get_selected_source_item_label($repository, $target_item, $source_item) {
  // No branch/tag support yet, might be implemented in the future.
  return NULL;
}


/**
 * Implementation of [versioncontrol_backend]_account():
 * Manage (insert, update or delete) additional SVN user account data
 * in the database.
 */
function versioncontrol_svn_account($op, $uid, $username, $repository, $additional_data = array()) {
  $svn_specific = $additional_data['svn_specific'];

  switch ($op) {
    case 'insert':
      if (!isset($svn_specific) || !isset($svn_specific['password'])) {
        drupal_set_message(t('Error: no SVN password given on account creation!'), 'error');
        return;
      }
      db_query("INSERT INTO {versioncontrol_svn_accounts}
                (uid, repo_id, password, serving_method)
                VALUES (%d, %d, '%s', %d)",
                $uid, $repository['repo_id'],
                $svn_specific['password'], $svn_specific['serving_method']);
      break;

    case 'update':
      if (!isset($svn_specific) || !isset($svn_specific['password'])) {
        // the user didn't update the password
        // (and neither the serving method, as a consequence).
        return;
      }
      db_query("UPDATE {versioncontrol_svn_accounts}
                SET password = '%s', serving_method = %d
                WHERE uid = %d AND repo_id = %d",
                $svn_specific['password'], $svn_specific['serving_method'],
                $uid, $repository['repo_id']);

      if (!user_access('administer version control systems')) {
        // Admins get "The account has been updated successfully" anyways.
        drupal_set_message(t('The SVN password has been updated successfully.'));
      }
      break;

    case 'delete':
      db_query("DELETE FROM {versioncontrol_svn_accounts}
                WHERE uid = %d AND repo_id = %d",
                $uid, $repository['repo_id']);
      break;
  }
}


/**
 * Menu callback for 'admin/project/versioncontrol-repositories/update/svn'
 * (expecting a $repo_id as one more path argument):
 * Retrieve/validate the specified repository, fetch new commits by invoking
 * the svn executable, output messages and redirect back to the repository page.
 */
function versioncontrol_svn_update_repository_callback($repo_id) {
  if (is_numeric($repo_id)) {
    $repository = versioncontrol_get_repository($repo_id);

    if (isset($repository)) {
      $update_method = $repository['svn_specific']['update_method'];
    }
  }
  if (isset($update_method) && $update_method == VERSIONCONTROL_SVN_UPDATE_CRON) {
    // Set timeout limit to 3600 seconds as it can take a long time
    // to process the log initially.
    if (!ini_get('safe_mode')) {
      set_time_limit(3600);
    }
    $message = _versioncontrol_svn_update_repository($repository);
    drupal_set_message($message);
  }
  else { // $repo_id is not a number or doesn't correlate to any repository.
    drupal_set_message(t('No such repository, did not fetch anything.'));
  }
  drupal_goto('admin/project/versioncontrol-repositories');
}

/**
 * Actually update the repository by fetching commits directly from
 * the repository, invoking the svn executable.
 *
 * @return
 *   TRUE if the logs were updated, or FALSE if fetching and updating the logs
 *   failed for whatever reason.
 */
function _versioncontrol_svn_update_repository(&$repository) {
  include_once(drupal_get_path('module', 'versioncontrol_svn') .'/versioncontrol_svn.log.inc');
  return _versioncontrol_svn_log_update_repository($repository);
}
